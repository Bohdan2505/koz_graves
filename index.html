<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Схема кладовища</title>


<script src="https://cdn.jsdelivr.net/npm/ol@v10.2.1/dist/ol.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.2.1/ol.css">


<style>
.rotate-north {
        top: 65px;
        left: .5em;
      }
      .ol-touch .rotate-north {
        top: 80px;
      }

</style>
</head>
<body>
    <div id="map" class="map" style="width: 100%; height: 90vh;"></div>
     <input id="refresh-lines" type="button" value="Увімкнути/Вимкнути підписи" />
    <script>
    const str_type = {
    1: "Вулиця",
    2: "Площа",
    3: "Майдан",
    4: "Шосе",
    5: "Проспект",
    6: "Бульвар",
    7: "Алея",
    8: "Провулок",
    9: "Проїзд",
    10: "Узвіз",
    11: "Тупик",
    12: "Набережна",
    14: "Шлях",
    15: "Дорога",
    16: "Заїзд",
    17: "В'їзд",
    18: "Завулок",
    19: "Лінія",
    101: "Мікрорайон",
    102: "Квартал",
    103: "Жилий масив",
    104: "Хутір",
    105: "Урочище"

}
    
    
        // Підключаємо СК EPSG:5561 через proj4
        proj4.defs("EPSG:5564","+proj=tmerc +lat_0=0 +lon_0=33 +k=1 +x_0=6500000 +y_0=0 +ellps=krass +towgs84=24,-121,-76,0,0,0,0 +units=m +no_defs +type=crs");
        
        proj4.defs("EPSG:7828","+proj=tmerc +lat_0=0.0833333333333333 +lon_0=32.5 +k=1 +x_0=4300000 +y_0=0 +ellps=krass +towgs84=24,-121,-76,0,0,0,0 +units=m +no_defs +type=crs");
        
        proj4.defs("EPSG:5561","+proj=longlat +ellps=krass +no_defs +towgs84=24,-121,-76,0,0,0,0 +type=crs");
        ol.proj.proj4.register(proj4);
        
        proj4.defs("EPSG:9854","+proj=tmerc +lat_0=0 +lon_0=33.8333333333333 +k=1 +x_0=300000 +y_0=0 +ellps=krass +towgs84=24,-121,-76,0,0,0,0 +units=m +no_defs +type=crs");
        ol.proj.proj4.register(proj4);
        
        var geojsonData = {
"type": "FeatureCollection",
"name": "cs63",
"crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:EPSG::7828" } },
"features": [
{ "type": "Feature", "properties": { }, "geometry": { "type": "Polygon", "coordinates": [ [ [ 4398498.308372817002237, 5445616.453762816265225 ], [ 4398512.409493075683713, 5445621.511236889287829 ], [ 4398515.224454880692065, 5445613.818613870069385 ], [ 4398512.045682289637625, 5445611.892933743074536 ], [ 4398516.232394011691213, 5445602.355803755111992 ], [ 4398536.447225360199809, 5445609.925393959507346 ], [ 4398540.643513272516429, 5445599.854455302469432 ], [ 4398507.637266562320292, 5445588.852664886042476 ], [ 4398498.308372817002237, 5445616.453762816265225 ] ] ] } }
]
}


// ####https://stackoverflow.com/questions/31297721/how-to-get-a-layer-from-a-feature-in-openlayers-3####
ol.Feature.prototype.getLayer = function(map) {
    var this_ = this, layer_, layersToLookFor = [];
    /**
     * Populates array layersToLookFor with only
     * layers that have features
     */
    var check = function(layer){
        var source = layer.getSource();
        if(source instanceof ol.source.Vector){
            var features = source.getFeatures();
            if(features.length > 0){
                layersToLookFor.push({
                    layer: layer,
                    features: features
                });
            }
        }
    };
    //loop through map layers
    map.getLayers().forEach(function(layer){
        if (layer instanceof ol.layer.Group) {
            layer.getLayers().forEach(check);
        } else {
            check(layer);
        }
    });
    layersToLookFor.forEach(function(obj){
        var found = obj.features.some(function(feature){
            return this_ === feature;
        });
        if(found){
            //this is the layer we want
            layer_ = obj.layer;
        }
    });
    return layer_;
};


const labelStyle = new ol.style.Style({
  text: new ol.style.Text({
    font: 'bold 13px "Open Sans", "Arial Unicode MS", "sans-serif"',
    overflow: true,
    fill: new ol.style.Fill({
      color: '#000',
    }),
    stroke: new ol.style.Stroke({
      color: '#fff',
      width: 3,
    }),
  }),
});




const countryStyle = new ol.style.Style({
  fill: new ol.style.Fill({
    color: 'rgba(255, 255, 255, 0.6)',
  }),
  stroke: new ol.style.Stroke({
    color: '#000',
    width: 1,
  }),
});
const style = [labelStyle, countryStyle];

let street_line_style_border =  new ol.style.Style({
      stroke: new ol.style.Stroke({ 
        color: '#000',
        width: 13,
      }),
      zIndex: 0,
    })
let street_line_style_middle = 
    new ol.style.Style({
      stroke: new ol.style.Stroke({ 
        color: '#fff',
        width: 10,
      }),
      zIndex: street_line_style_border.getZIndex() + 1,
    })


let street_label_style = new ol.style.Style({
  text: new ol.style.Text({
    font: 'bold 15px "Open Sans", "Arial Unicode MS", "sans-serif"',
    // overflow: true,
    placement: 'line',
    fill: new ol.style.Fill({
      color: 'black',
    }),
    stroke: new ol.style.Stroke({
    color: '#fff',
    width: 1,
  }),
  }),
  zIndex: street_line_style_border.getZIndex() + 2,
});

street_style = [street_line_style_border, street_line_style_middle, street_label_style]

// streets_data_Talne
// buildings_data_Talne
        // Створюємо векторний шар з GeoJSON



        const vectorLayer = new ol.layer.VectorImage({
            source: new ol.source.Vector({
            features: new ol.format.GeoJSON().readFeatures(buildings_data_Talne, {
      // dataProjection: 'EPSG:7828',
      featureProjection: 'EPSG:3857'
    }),
                // url: 'your-data.geojson', // URL до файлу GeoJSON
                format: new ol.format.GeoJSON()
            }), 
            title:'Buildings '
            
              // style: style_buildings_with_labels,
  },
  // renderMode: 'vector'
  // declutter: true,
        );

  function style_buildings_without_labels(feature, resolution) {
  return countryStyle
  }
function style_buildings_with_labels(feature, resolution) {
              var zoom = map.getView().getZoomForResolution(resolution);
    
    
    if (zoom >= 17) {
    let build_num = feature.get('build_num') != null ? feature.get('build_num').split(' ').join('\n') : ''

    let build_label = build_num;
    labelStyle.getText().setText(build_label);
    
    }
    else {
    labelStyle.getText().setText('');
    // style.getText().setText('')
    }
    return style;
        

}        

vectorLayer.setStyle(style_buildings_without_labels)
        
       const streetvectorLayer = new ol.layer.VectorImage({
            source: new ol.source.Vector({
            features: new ol.format.GeoJSON().readFeatures(streets_data_Talne, {
      // dataProjection: 'EPSG:7828',
      featureProjection: 'EPSG:3857'
    }),
  
                // url: 'your-data.geojson', // URL до файлу GeoJSON
                format: new ol.format.GeoJSON()
            }),
              title: 'Streets',
    declutter: true,
            
              style: function (feature, resolution) {
              var zoom = map.getView().getZoomForResolution(resolution);
    
    
    if (zoom >= 17) {
    let street_name = feature.get('name_old') != null ? `${str_type[feature.get('str_type')]} ${feature.get('str_name')} (${feature.get('name_old')})` : `${str_type[feature.get('str_type')]} ${feature.get('str_name')}`
    let street_label = street_name;
    // street_label_style.setGeometry(feature.getGeometry().simplify(2));
    street_label_style.getText().setText(street_label);
    
    }
    else {
    street_label_style.getText().setText('');
    // style.getText().setText('')
    }
    return street_style;
  },
  // declutter: true,
        });
        
        var FullScreen = new ol.control.FullScreen({className: 'ol-full-screen', tipLabel: 'Toggle full-screen'});;


        class RotateNorthControl extends ol.control.Control {
  /**
   * @param {Object} [opt_options] Control options.
   */
  constructor(opt_options) {
    const options = opt_options || {};

    const button = document.createElement('button');
    button.innerHTML = 'N';

    const element = document.createElement('div');
    element.className = 'rotate-north ol-unselectable ol-control';
    element.appendChild(button);

    super({
      element: element,
      target: options.target,
    });

    button.addEventListener('click', this.handleRotateNorth.bind(this), false);
  }

  handleRotateNorth() {
    this.getMap().getView().setRotation(0);
  }
}
let layerSwitcher = new LayerSwitcher({
  reverse: true,
  groupSelectStyle: 'group'
});
// map.addControl(layerSwitcher);
// Тепер ви можете використовувати їх у своєму коді:
// var controls = defaultControls().extend([new ol.control.FullScreen()]);


        // Створюємо карту
        const map = new ol.Map({
          controls: ol.control.defaults.defaults().extend([layerSwitcher, FullScreen, new RotateNorthControl]),
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM() // Базова карта
                }),
                vectorLayer,
                streetvectorLayer// Векторний шар
            ],
            view: new ol.View({
                center: ol.proj.transform([30.71848965391502, 48.89], 'EPSG:4326', 'EPSG:3857'), // Центруємо карту на певних координатах
                zoom: 14 // Початковий масштаб
            }),
            // renderer: 'webgl'
        });
        
        
        let state_label = 1
        
        document.getElementById('refresh-lines').addEventListener('click', function () {
        if (state_label == 1) {
        
        vectorLayer.setStyle(style_buildings_with_labels)
        
        state_label = 0
        }
        
        else {
         vectorLayer.setStyle(style_buildings_without_labels)
         state_label = 1
        }
          
  
 
  // vectorLines.setStyle(lineStyleFunction);
});
const selectStyle = new ol.style.Style({
  fill: new ol.style.Fill({
    color: '#eeeeee',
  }),
  stroke: new ol.style.Stroke({
    color: 'rgba(255, 255, 255, 0.7)',
    width: 2,
  }),
});

let selected = null;

// let selectClick = new ol.interaction.Select({});
// map.addInteraction(selectClick);
// 
// selectClick.on('select', function(e) {
//     let featureSelected = e.selected[0];
//     console.log(e.selected)
//     let layer = selectClick.getLayer(featureSelected);
//     console.log(layer); // here you have the selected layer
// });

map.on('click', function (e) {
  // if (selected !== null) {
  //   selected.setStyle(undefined);
  //   selected = null;
  // }

  all_features = map.getFeaturesAtPixel(e.pixel)
    console.log(all_features)
  // console.log(
  if (all_features.length >0) {
  console.log(all_features[0].getLayer(map).get('title'))
  }
  
  
  map.forEachFeatureAtPixel(e.pixel, function (f, layer) {
    selected = f;
    // console.log(f)
    // selectStyle.getFill().setColor(f.get('COLOR') || '#eeeeee');
    // f.setStyle(selectStyle);
    return true;
  });

});


// map.addControl(FullScreen)

// map.addControl(new RotateNorthControl)
    </script>
</body>
</html>
